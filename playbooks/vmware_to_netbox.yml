---
# Playbook para sincronizar VMs do inventÃ¡rio VMware para o NetBox
# Arquivo: playbooks/vmware_to_netbox.yml

- name: ğŸŒ Sincronizar VMs VMware para NetBox
  hosts: all
  gather_facts: false
  vars:
    ansible_connection: local
    # ConfiguraÃ§Ãµes do NetBox (fornecidas via Custom Credential "Netbox Credentials")
    netbox_url: "{{ lookup('env', 'NETBOX_API') }}"
    netbox_token: "{{ lookup('env', 'NETBOX_TOKEN') }}"

    # ConfiguraÃ§Ãµes de sincronizaÃ§Ã£o
    batch_size: 50
    create_missing_objects: true
    update_existing: true
    dry_run: false

  tasks:
    - name: ğŸ§¹ Limpar variÃ¡veis problemÃ¡ticas do AWX
      set_fact:
        remote_host_enabled: null
        remote_host_id: null
        remote_tower_enabled: null
        remote_tower_id: null
        tower_enabled: null
        tower_id: null
        awx_enabled: null
        awx_id: null

    - name: â­ï¸ Pular VMs sem dados essenciais
      meta: end_host
      when: vm_name is undefined or vm_name == ""

    - name: ğŸ“‹ Preparar dados da VM do inventÃ¡rio AWX
      set_fact:
        vm_meta:
          name: "{{ vm_name }}"
          uuid: "{{ vm_uuid }}"
          vcpus: "{{ vm_cpu_count | default(1) }}"
          memory: "{{ vm_memory_mb | default(1024) }}"
          disk: "{{ 20 }}"  # Default 20GB
          cluster: "{{ vm_cluster | default('default-cluster') }}"
          datacenter: "{{ vm_datacenter | default('ATI-SLC-HCI') }}"
          status: "{{ 'active' if vm_power_state == 'poweredOn' else 'offline' if vm_power_state == 'poweredOff' else 'staged' }}"
          interfaces: >-
            {% set interfaces = [] %}
            {% if vm_ip_addresses is defined and vm_ip_addresses | length > 0 %}
              {% for ip in vm_ip_addresses %}
                {% set interface = {
                  'name': 'eth' + loop.index0|string,
                  'macaddress': '00:50:56:' + '%02x:%02x:%02x'|format(
                    range(0, 256)|random,
                    range(0, 256)|random, 
                    range(0, 256)|random
                  ),
                  'ipaddresses': [ip]
                } %}
                {% set _ = interfaces.append(interface) %}
              {% endfor %}
            {% endif %}
            {{ interfaces }}

    - name: ğŸ“Š Debug dados da VM preparados
      debug:
        msg: |
          ğŸ–¥ï¸ VM: {{ vm_meta.name }}
          ğŸ”Œ Estado: {{ vm_meta.status }}
          ğŸ§  CPUs: {{ vm_meta.vcpus }}
          ğŸ’¾ MemÃ³ria: {{ vm_meta.memory }}MB
          ğŸŒ IPs: {{ vm_meta.interfaces | map(attribute='ipaddresses') | flatten | join(', ') }}
          ğŸ¢ Datacenter: {{ vm_meta.datacenter }}
          ğŸ”§ Cluster: {{ vm_meta.cluster }}

    - name: ğŸ“Š Exibir estatÃ­sticas iniciais
      debug:
        msg: |
          ğŸŒ SINCRONIZAÃ‡ÃƒO VMWARE â†’ NETBOX
          ================================
          ğŸ¯ Total de VMs para processar: {{ ansible_play_hosts | length }}
          âœ… VMs Ligadas (poweredOn â†’ Active): {{ groups['powered_on'] | default([]) | length }}
          âŒ VMs Desligadas (poweredOff â†’ Offline): {{ groups['powered_off'] | default([]) | length }}
          â¸ï¸  VMs Suspensas (suspended â†’ Staged): {{ groups['suspended'] | default([]) | length }}
          ğŸ”— NetBox URL: {{ netbox_url }}
          ğŸ”„ Modo: {{ 'DRY RUN' if dry_run else 'PRODUÃ‡ÃƒO' }}
          ğŸ“¦ Tamanho do lote: {{ batch_size }}
      run_once: true
      delegate_to: localhost

    - name: ğŸ”„ Exibir mapeamento de status VMware â†’ NetBox
      debug:
        msg: |
          ğŸ“‹ MAPEAMENTO DE STATUS:
          ======================
          âœ… poweredOn (VMware) â†’ active (NetBox)
          âŒ poweredOff (VMware) â†’ offline (NetBox)  
          â¸ï¸  suspended (VMware) â†’ staged (NetBox)
          
          ğŸ“Š DISTRIBUIÃ‡ÃƒO ATUAL:
          â€¢ VMs que ficarÃ£o Active: {{ groups['powered_on'] | default([]) | length }}
          â€¢ VMs que ficarÃ£o Offline: {{ groups['powered_off'] | default([]) | length }}
          â€¢ VMs que ficarÃ£o Staged: {{ groups['suspended'] | default([]) | length }}
      run_once: true
      delegate_to: localhost

    - name: ğŸ—ï¸ Criar site no NetBox (se necessÃ¡rio)
      netbox.netbox.netbox_site:
        netbox_url: "{{ netbox_url }}"
        netbox_token: "{{ netbox_token }}"
        data:
          name: "{{ vm_meta.datacenter }}"
          slug: "{{ vm_meta.datacenter | lower | replace(' ', '-') | regex_replace('[^a-z0-9-]', '-') }}"
          status: active
          description: "Site criado automaticamente via AWX"
        state: present
      delegate_to: localhost
      when: not dry_run

    - name: ğŸ­ Criar tipo de cluster VMware
      netbox.netbox.netbox_cluster_type:
        netbox_url: "{{ netbox_url }}"
        netbox_token: "{{ netbox_token }}"
        data:
          name: VMware
          slug: vmware
          description: "VMware vSphere Clusters"
        state: present
      delegate_to: localhost
      run_once: true
      when: not dry_run

    - name: ğŸ” Verificar se cluster existe
      uri:
        url: "{{ netbox_url }}/api/virtualization/clusters/?name={{ vm_meta.cluster | urlencode }}"
        headers:
          Authorization: "Token {{ netbox_token }}"
        method: GET
        return_content: yes
        validate_certs: false
      register: cluster_check
      delegate_to: localhost
      when: not dry_run

    - name: ğŸ—ï¸ Criar cluster se nÃ£o existir
      netbox.netbox.netbox_cluster:
        netbox_url: "{{ netbox_url }}"
        netbox_token: "{{ netbox_token }}"
        data:
          name: "{{ vm_meta.cluster }}"
          site: "{{ vm_meta.datacenter }}"
          cluster_type: VMware
          description: "Cluster criado automaticamente via AWX"
        state: present
      delegate_to: localhost
      when: 
        - not dry_run
        - cluster_check.json.count | int == 0

    - name: ğŸ–¥ï¸ Criar/atualizar VM no NetBox
      netbox.netbox.netbox_virtual_machine:
        netbox_url: "{{ netbox_url }}"
        netbox_token: "{{ netbox_token }}"
        data:
          name: "{{ vm_meta.name }}"
          vcpus: "{{ vm_meta.vcpus | int }}"
          memory: "{{ (vm_meta.memory | float / 1024) | round(0, 'floor') | int }}"
          disk: "{{ vm_meta.disk | float | round(0, 'floor') | int }}"
          cluster: "{{ vm_meta.cluster }}"
          status: "{{ vm_meta.status }}"
          description: |
            VM importada automaticamente do vCenter via AWX
            UUID: {{ vm_meta.uuid }}
            SO: {{ vm_guest_os | default('Unknown') }}
            Cluster: {{ vm_meta.cluster }}
            Datacenter: {{ vm_meta.datacenter }}
            Ambiente: {{ vm_environment | default('unknown') }}
            Criticidade: {{ vm_criticality | default('low') }}
            Ferramentas VMware: {{ vm_tools_status | default('unknown') }}
        state: present
      delegate_to: localhost
      when: not dry_run

    - name: ğŸ” Verificar se a VM possui interfaces
      set_fact:
        vm_interfaces_raw: "{{ vm_meta.interfaces | default([]) }}"

    - name: ğŸŒ Filtrar interfaces com IPs
      set_fact:
        interfaces_com_ip: >-
          {{ vm_interfaces_raw
             | selectattr('ipaddresses', 'defined')
             | selectattr('ipaddresses', '!=', '')
             | selectattr('ipaddresses', '!=', [])
             | list }}

    - name: ğŸŒ Criar/atualizar interfaces (com MAC)
      netbox.netbox.netbox_vm_interface:
        netbox_url: "{{ netbox_url }}"
        netbox_token: "{{ netbox_token }}"
        data:
          virtual_machine: "{{ vm_meta.name }}"
          name: "{{ iface.name }}"
          enabled: true
          mac_address: "{{ iface.macaddress }}"
          description: "Interface criada automaticamente via AWX"
        state: present
      loop: "{{ interfaces_com_ip }}"
      loop_control:
        loop_var: iface
        label: "{{ iface.name }}"
      delegate_to: localhost
      when: 
        - not dry_run
        - interfaces_com_ip | length > 0

    - name: ğŸ”¢ Criar IPs no IPAM
      netbox.netbox.netbox_ip_address:
        netbox_url: "{{ netbox_url }}"
        netbox_token: "{{ netbox_token }}"
        data:
          address: "{{ item.1 }}{{ '/128' if ':' in item.1 else '/32' }}"
          status: active
          description: "IP da VM {{ vm_meta.name }} criado via AWX"
        state: present
      loop: "{{ interfaces_com_ip | subelements('ipaddresses') }}"
      loop_control:
        label: "{{ item.1 }}"
      delegate_to: localhost
      when: 
        - not dry_run
        - interfaces_com_ip | length > 0

    - name: ğŸ” Obter interfaces da VM no NetBox
      uri:
        url: "{{ netbox_url }}/api/virtualization/interfaces/?virtual_machine={{ vm_meta.name }}"
        headers:
          Authorization: "Token {{ netbox_token }}"
        method: GET
        return_content: yes
        validate_certs: false
      register: vm_interfaces
      delegate_to: localhost
      when: 
        - not dry_run
        - interfaces_com_ip | length > 0

    - name: ğŸ” Obter IDs de IPs existentes
      uri:
        url: "{{ netbox_url }}/api/ipam/ip-addresses/?address={{ item.1 }}{{ '/128' if ':' in item.1 else '/32' }}"
        headers:
          Authorization: "Token {{ netbox_token }}"
        method: GET
        return_content: yes
        validate_certs: false
      register: ip_query
      loop: "{{ interfaces_com_ip | subelements('ipaddresses') }}"
      loop_control:
        label: "{{ item.1 }}"
      retries: 3
      delay: 2
      until: ip_query.status == 200
      delegate_to: localhost
      when: 
        - not dry_run
        - interfaces_com_ip | length > 0

    - name: ğŸ”— Montar mapeamento IP â†” interface
      set_fact:
        ip_interface_map: "{{ ip_interface_map | default([]) + [ new_map ] }}"
      vars:
        iface_name: "{{ item.0.0.name }}"
        ip_id: "{{ item.1.json.results[0].id }}"
        iface_id: >-
          {{ vm_interfaces.json.results
             | selectattr('name', 'equalto', iface_name)
             | map(attribute='id')
             | first }}
        new_map:
          ip_id: "{{ ip_id }}"
          iface_id: "{{ iface_id }}"
      loop: "{{ query('subelements', interfaces_com_ip, 'ipaddresses') | zip(ip_query.results) | list }}"
      loop_control:
        label: "{{ item.0.1 }}"
      when: 
        - not dry_run
        - interfaces_com_ip | length > 0

    - name: ğŸ”— Associar IPs Ã s interfaces
      uri:
        url: "{{ netbox_url }}/api/ipam/ip-addresses/{{ item.ip_id }}/"
        method: PATCH
        headers:
          Authorization: "Token {{ netbox_token }}"
          Content-Type: application/json
        body_format: json
        body:
          assigned_object_type: virtualization.vminterface
          assigned_object_id: "{{ item.iface_id }}"
        status_code: [200, 204]
      loop: "{{ ip_interface_map }}"
      loop_control:
        label: "IP {{ item.ip_id }} â†’ Interface {{ item.iface_id }}"
      delegate_to: localhost
      when: 
        - not dry_run
        - ip_interface_map is defined

    - name: ğŸ“ Log do resultado da sincronizaÃ§Ã£o
      debug:
        msg: |
          {% if dry_run %}
          ğŸ” DRY RUN - VM {{ vm_meta.name }}:
          â”œâ”€ Nome: {{ vm_meta.name }}
          â”œâ”€ IPs: {{ vm_meta.interfaces | map(attribute='ipaddresses') | flatten | join(', ') if vm_meta.interfaces else 'N/A' }}
          â”œâ”€ SO: {{ vm_guest_os | default('Unknown') }}
          â”œâ”€ Estado: {{ vm_meta.status }}
          â”œâ”€ CPU: {{ vm_meta.vcpus }} cores
          â”œâ”€ MemÃ³ria: {{ vm_meta.memory }}MB
          â”œâ”€ Cluster: {{ vm_meta.cluster }}
          â””â”€ Datacenter: {{ vm_meta.datacenter }}
          {% else %}
          âœ… VM {{ vm_meta.name }} processada com sucesso no NetBox
          â”œâ”€ Estado: {{ vm_meta.status }}
          â”œâ”€ Interfaces: {{ interfaces_com_ip | length }} criadas
          â””â”€ IPs: {{ vm_meta.interfaces | map(attribute='ipaddresses') | flatten | length }} associados
          {% endif %}

- name: ğŸ“Š RelatÃ³rio Final de SincronizaÃ§Ã£o
  hosts: localhost
  gather_facts: false
  vars:
    ansible_connection: local
  run_once: true

  tasks:
    - name: ğŸ“‹ Gerar estatÃ­sticas finais
      debug:
        msg: |

          â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
          â•‘           RELATÃ“RIO DE SINCRONIZAÃ‡ÃƒO           â•‘
          â•‘              VMWARE â†’ NETBOX                   â•‘
          â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
          â•‘ ğŸ¯ Total de VMs processadas: {{ ansible_play_hosts | length }}               â•‘
          â•‘ ğŸŒ NetBox URL: {{ netbox_url }}
          â•‘ ğŸ”„ Modo: {{ 'DRY RUN (simulaÃ§Ã£o)' if dry_run else 'PRODUÃ‡ÃƒO (real)' }}                    â•‘
          â•‘ â° Executado em: {{ ansible_date_time.iso8601 }}     â•‘
          â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

          ğŸ’¡ Para executar em modo de produÃ§Ã£o:
             Desmarque a variÃ¡vel 'dry_run' ou defina como false

          ğŸ”§ Para customizar:
             â€¢ batch_size: Tamanho do lote de processamento
             â€¢ update_existing: Atualizar VMs existentes
             â€¢ create_missing_objects: Criar objetos faltantes
